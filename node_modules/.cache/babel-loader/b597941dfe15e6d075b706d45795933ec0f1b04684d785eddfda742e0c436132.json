{"ast":null,"code":"'use strict';\n\nvar isObj = require('is-obj');\nmodule.exports.get = function (obj, path) {\n  if (!isObj(obj) || typeof path !== 'string') {\n    return obj;\n  }\n  var pathArr = getPathSegments(path);\n  for (var i = 0; i < pathArr.length; i++) {\n    var descriptor = Object.getOwnPropertyDescriptor(obj, pathArr[i]) || Object.getOwnPropertyDescriptor(Object.prototype, pathArr[i]);\n    if (descriptor && !descriptor.enumerable) {\n      return;\n    }\n    obj = obj[pathArr[i]];\n    if (obj === undefined || obj === null) {\n      // `obj` is either `undefined` or `null` so we want to stop the loop, and\n      // if this is not the last bit of the path, and\n      // if it did't return `undefined`\n      // it would return `null` if `obj` is `null`\n      // but we want `get({foo: null}, 'foo.bar')` to equal `undefined` not `null`\n      if (i !== pathArr.length - 1) {\n        return undefined;\n      }\n      break;\n    }\n  }\n  return obj;\n};\nmodule.exports.set = function (obj, path, value) {\n  if (!isObj(obj) || typeof path !== 'string') {\n    return;\n  }\n  var pathArr = getPathSegments(path);\n  for (var i = 0; i < pathArr.length; i++) {\n    var p = pathArr[i];\n    if (!isObj(obj[p])) {\n      obj[p] = {};\n    }\n    if (i === pathArr.length - 1) {\n      obj[p] = value;\n    }\n    obj = obj[p];\n  }\n};\nmodule.exports.delete = function (obj, path) {\n  if (!isObj(obj) || typeof path !== 'string') {\n    return;\n  }\n  var pathArr = getPathSegments(path);\n  for (var i = 0; i < pathArr.length; i++) {\n    var p = pathArr[i];\n    if (i === pathArr.length - 1) {\n      delete obj[p];\n      return;\n    }\n    obj = obj[p];\n  }\n};\nmodule.exports.has = function (obj, path) {\n  if (!isObj(obj) || typeof path !== 'string') {\n    return false;\n  }\n  var pathArr = getPathSegments(path);\n  for (var i = 0; i < pathArr.length; i++) {\n    obj = obj[pathArr[i]];\n    if (obj === undefined) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction getPathSegments(path) {\n  var pathArr = path.split('.');\n  var parts = [];\n  for (var i = 0; i < pathArr.length; i++) {\n    var p = pathArr[i];\n    while (p[p.length - 1] === '\\\\' && pathArr[i + 1] !== undefined) {\n      p = p.slice(0, -1) + '.';\n      p += pathArr[++i];\n    }\n    parts.push(p);\n  }\n  return parts;\n}","map":{"version":3,"names":["isObj","require","module","exports","get","obj","path","pathArr","getPathSegments","i","length","descriptor","Object","getOwnPropertyDescriptor","prototype","enumerable","undefined","set","value","p","delete","has","split","parts","slice","push"],"sources":["/Users/jordane/Desktop/WalletScan/scan/node_modules/dot-prop/index.js"],"sourcesContent":["'use strict';\nvar isObj = require('is-obj');\n\nmodule.exports.get = function (obj, path) {\n\tif (!isObj(obj) || typeof path !== 'string') {\n\t\treturn obj;\n\t}\n\n\tvar pathArr = getPathSegments(path);\n\n\tfor (var i = 0; i < pathArr.length; i++) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, pathArr[i]) || Object.getOwnPropertyDescriptor(Object.prototype, pathArr[i]);\n\t\tif (descriptor && !descriptor.enumerable) {\n\t\t\treturn;\n\t\t}\n\n\t\tobj = obj[pathArr[i]];\n\n\t\tif (obj === undefined || obj === null) {\n\t\t\t// `obj` is either `undefined` or `null` so we want to stop the loop, and\n\t\t\t// if this is not the last bit of the path, and\n\t\t\t// if it did't return `undefined`\n\t\t\t// it would return `null` if `obj` is `null`\n\t\t\t// but we want `get({foo: null}, 'foo.bar')` to equal `undefined` not `null`\n\t\t\tif (i !== pathArr.length - 1) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nmodule.exports.set = function (obj, path, value) {\n\tif (!isObj(obj) || typeof path !== 'string') {\n\t\treturn;\n\t}\n\n\tvar pathArr = getPathSegments(path);\n\n\tfor (var i = 0; i < pathArr.length; i++) {\n\t\tvar p = pathArr[i];\n\n\t\tif (!isObj(obj[p])) {\n\t\t\tobj[p] = {};\n\t\t}\n\n\t\tif (i === pathArr.length - 1) {\n\t\t\tobj[p] = value;\n\t\t}\n\n\t\tobj = obj[p];\n\t}\n};\n\nmodule.exports.delete = function (obj, path) {\n\tif (!isObj(obj) || typeof path !== 'string') {\n\t\treturn;\n\t}\n\n\tvar pathArr = getPathSegments(path);\n\n\tfor (var i = 0; i < pathArr.length; i++) {\n\t\tvar p = pathArr[i];\n\n\t\tif (i === pathArr.length - 1) {\n\t\t\tdelete obj[p];\n\t\t\treturn;\n\t\t}\n\n\t\tobj = obj[p];\n\t}\n};\n\nmodule.exports.has = function (obj, path) {\n\tif (!isObj(obj) || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\tvar pathArr = getPathSegments(path);\n\n\tfor (var i = 0; i < pathArr.length; i++) {\n\t\tobj = obj[pathArr[i]];\n\n\t\tif (obj === undefined) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\nfunction getPathSegments(path) {\n\tvar pathArr = path.split('.');\n\tvar parts = [];\n\n\tfor (var i = 0; i < pathArr.length; i++) {\n\t\tvar p = pathArr[i];\n\n\t\twhile (p[p.length - 1] === '\\\\' && pathArr[i + 1] !== undefined) {\n\t\t\tp = p.slice(0, -1) + '.';\n\t\t\tp += pathArr[++i];\n\t\t}\n\n\t\tparts.push(p);\n\t}\n\n\treturn parts;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}